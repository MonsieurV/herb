#+SEQ_TODO: NEXT(t) TODO(t) WAITING(w) MAYBE(m) | DONE(d) PARTIAL(p) CANCELLED(c)
* IDEAS
** Use set in injected styles instead of map to ensure no duplicates
** Use tree-seq when resolving styles
** [[https://github.com/noprompt/garden/issues/24][Support for existing CSS resources · Issue #24 · noprompt/garden]]
** [[https://www.w3.org/wiki/Dynamic_style_-_manipulating_CSS_with_JavaScript][Dynamic style - manipulating CSS with JavaScript - W3C Wiki]]
* TESTS
** DONE Test for inheritance, make sure the chain is respected for modes and media
   CLOSED: [2018-02-17 Sat 20:18]
** TODO Test that the classname contains a full namespace
** [[https://github.com/igrishaev/etaoin/blob/master/test/etaoin/api_test.clj][etaoin/api_test.clj at master · igrishaev/etaoin]]
** [[https://github.com/igrishaev/etaoin][igrishaev/etaoin: Pure Clojure Webdriver protocol implementation]]
* DOCS
** TODO refer vs refer-macros
** TODO group args
* DEMO
** TODO demo inheritance variants
** TODO demo state
** TODO demo media
** TODO demo keys
** TODO demo anon
** TODO demo group/defgroup
*** Demo meta data in groups
** TODO demo nested
** TODO Add demo for selecting elements by class
* &env macro
  In order to evaluate things in context, you first need to garner the bindings
  in the current context. Fortunately, Clojure macros provide an implicit
  argument ~&env~ that’s a map of the local bindings available at macro-expansion
  time. You can extract from ~&env~ the values associated with the bindings and
  zip them up with their names into a map for the local context, as shown next.

  #+BEGIN_SRC clojure
    (defmacro local-context []
      (let [symbols (keys &env)] ; Use the special &env
        (zipmap (map (fn [sym] `(quote ~sym)) ; Zip up the local names with local values
                     symbols)
                symbols)))
  #+END_SRC

  One interesting point is the use of the ~&env~ symbol. This special symbol holds
  the value of the bindings available to the macro in which it occurs. The
  bindings are of a special type that is opaque to your direct inspection, but by
  putting them into the return map you can build a Clojure data structure from
  them for direct use and manipulation. Observe ~local-context~ in action:

  #+BEGIN_SRC clojure
    (local-context)
    ;=> {}

    (let [a 1, b 2, c 3]
      (let [b 200]
        (local-context)))
    ;=> {a 1, b 200, c 3}
  #+END_SRC

  The ~local-context~ macro provides a map to the most immediate lexical bindings,
  which is what you want.

* TODO Spec input
* TODO Fix single rule not causing newline
* TODO Do new perf test
* TODO Check merge order of extensions in form [style1 style2]
* MAYBE Add helper macro for defining component function
* TODO ::after ::before
* TODO Mention clojurescript version and requiring functions
* TODO Optimize css on prod
* TODO Change defgroup to stylegroup
* DONE Test to see if you can deref ratoms directly in styles
  CLOSED: [2018-05-22 Tue 20:45]
* DONE Rename mode to pseudo, allow for arbitrary forms
  CLOSED: [2018-05-22 Tue 20:45]
* CANCELLED Add global init
  CLOSED: [2018-04-05 Thu 12:35]
  Possibly create instances?
* DONE Try wrapping macros in reader cond
  CLOSED: [2018-05-22 Tue 20:46]
* TODO What happens when trying to extend a style group with no arguments?
* TODO Use loop in recur functions herb
* TODO Some way to target static classnames
* TODO Remove data-herb when prod build
* TODO Add note about setting debug flag to false on prod builds
* TODO Look into using more complex classname chars
  I know css supports a larger range of classname chars but I think passing
  through hiccup or reagent they get sanitized
* TODO @supports
